# 标签页替换功能测试

## 功能概述

当标签页达到最大上限时，再次打开新的标签页会替换掉最后一个（最右边的）非固定标签页，确保标签页数量不会超过设定的上限。

## 实现机制

### 1. 标签页替换逻辑
- ✅ 当标签页数量达到最大上限时，新标签页会替换最后一个非固定标签页
- ✅ 固定标签页不会被替换，始终保持显示
- ✅ 如果所有标签页都是固定的，新标签页会被跳过

### 2. 替换策略
- ✅ 从后往前查找第一个非固定标签页进行替换
- ✅ 保持固定标签页的优先级和位置
- ✅ 替换后重新应用排序逻辑

### 3. 日志输出
- ✅ 替换操作有详细的日志输出
- ✅ 区分添加新标签和替换标签的操作
- ✅ 记录被替换的标签页信息

## 测试步骤

### 基础替换测试
1. **达到上限时的替换**
   - 创建标签页直到达到最大上限
   - 打开一个新的标签页
   - 验证最后一个非固定标签页被替换
   - 验证控制台输出替换信息

2. **固定标签页保护**
   - 固定一些标签页
   - 达到最大上限后打开新标签页
   - 验证固定标签页不被替换
   - 验证只有非固定标签页被替换

3. **全部固定标签页的情况**
   - 将所有标签页都固定
   - 尝试打开新标签页
   - 验证新标签页被跳过
   - 验证控制台输出跳过信息

### 边界情况测试
1. **最大标签数为1**
   - 设置最大标签数为1
   - 打开新标签页
   - 验证替换逻辑正常工作

2. **最大标签数为0**
   - 设置最大标签数为0
   - 验证不会添加任何标签页

3. **动态调整最大标签数**
   - 在运行时调整最大标签数
   - 验证替换逻辑适应新的上限

### 性能测试
1. **大量标签页替换**
   - 创建大量标签页
   - 频繁打开新标签页
   - 验证替换性能良好

2. **固定标签页较多的情况**
   - 固定大部分标签页
   - 验证查找最后一个非固定标签页的性能

## 预期结果

- 标签页数量始终不超过最大上限
- 固定标签页永远不会被替换
- 替换操作有清晰的日志输出
- 替换后标签页排序正确
- 性能表现良好

## 技术细节

### 核心方法
- `findLastNonPinnedTabIndex()` - 查找最后一个非固定标签页的索引
- `mergeFirstPanelTabs()` - 合并标签页时的替换逻辑
- `checkFirstPanelBlocks()` - 检查新块时的替换逻辑

### 替换算法
```typescript
// 查找最后一个非固定标签页
findLastNonPinnedTabIndex(): number {
  for (let i = this.firstPanelTabs.length - 1; i >= 0; i--) {
    if (!this.firstPanelTabs[i].isPinned) {
      return i;
    }
  }
  return -1; // 没有找到非固定标签页
}

// 替换逻辑
if (this.firstPanelTabs.length >= this.maxTabs) {
  const lastNonPinnedIndex = this.findLastNonPinnedTabIndex();
  if (lastNonPinnedIndex !== -1) {
    const replacedTab = this.firstPanelTabs[lastNonPinnedIndex];
    this.firstPanelTabs[lastNonPinnedIndex] = newTab;
  }
}
```

### 日志输出示例
```
🔄 标签页达到上限，替换最后一个标签: "旧标签" -> "新标签"
➕ 添加新标签: "新标签"
⚠️ 所有标签都是固定的，无法添加新标签: "新标签"
```

## 解决的问题

1. **标签页数量控制**：确保标签页数量不超过设定上限
2. **固定标签页保护**：固定标签页永远不会被替换
3. **用户体验**：新标签页总是能够显示，不会因为达到上限而被忽略
4. **性能优化**：高效的查找和替换算法
